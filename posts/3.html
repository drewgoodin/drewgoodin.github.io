<p><!DOCTYPE HTML>
<html lang='EN-US'>
  <head>
    <meta charset = "UTF-8">
    <title>Drew K Goodin</title>
    <meta name = "viewport" content = "width=device-width">
    <meta name = "viewport" content = "initial-scale=1.0">
    <link rel = "stylesheet"
      type = "text/css"
      href = "/style.css" />
  </head>
  <body>
<a href="/blog.html">Blog home</a></p>

<h2>HTML::Mason and PSGI; a uniting module</h2>

<p>Note: this is not about HTML::Mason::PSGIHandler, a module that I did not know existed before I came up with my own solution.</p>

<p><a href="http://plackperl.org">PSGI</a> specifies a simple way for Perl applications to talk to (PSGI compliant) web servers. A PSGI application file must include a Perl subroutine reference that returns a three-element array reference: the HTTP response code, an array reference of headers, and an array reference (or possibly a filehandle) containing the response body. The subroutine reference is should be the last declared item in the file. A PSGI-compliant server calls this file and loads the application.</p>

<p>In its simplest form, a PSGI application file can return the array reference directly, but for most any application beyond the trivial, it will call Perl code that the application developer has factored into packages which in turn return construct and return the array reference. Moreover, the major Perl web frameworks do this for you, abstracting you away from PSGI entirely.</p>

<p>Nevertheless, I wrote a <a href="https://github.com/goodind1/slurm">module</a> (source) that allows the use of HTML::Mason, my favorite templating engine/framework, with PSGI.</p>

<p>The module consists of three packages/classes:</p>

<ul>
<li><p>Slurm::Response: Constructs the PSGI array reference. The run() subroutine takes in the environment hash passed in by Plack when the server is started and the app is run. It uses this to try and figure out the Content-type and body of the response, with the help of the other two packages:</p></li>
<li><p>Slurm::Type: Contains a function that determines Content-type by comparing file extensions to a user-populated configuration file. If it can't, text/html is used.</p></li>
<li><p>Slurm::View: Contains a function that determines the response body. The function passes the path of the requested URI to an HTML::Mason::Interp object, along with any query string/content arguments and the entire Plack environment hash. This additional data can be accessed in Mason components by declaring appropriate 'args' sections.</p></li>
</ul>

<p>Here is a minimal app.psgi to use the module:</p>

<pre><code>use Slurm::Response;

my $app = sub { 
    my $resp = Slurm::Response-&gt;new(shift);
    $resp-&gt;send;
};
</code></pre>

<p>To get the module, download the tarball <a href="https://github.com/goodind1/slurm/releases/download/v0.1/Slurm-0.tar.gz">here</a> and install with <code>cpan</code> or <code>cpanm</code>.</p>

<p>Just use an <code>app.psgi</code> file like the above, or do something more sophisticated via Plack::Builder (there is a lot of great Plack middleware that you can easily wrap your Mason application with). In the same directory as your psgi file, you will need to create a directory called "components" as the component root for Mason, and optionally a plain text file called ".mime_types". See the link to the module source above for more information.</p>

<p>After that, <code>plackup app.psgi</code> will serve your Mason application on port 5000.
  </body>
</html></p>
